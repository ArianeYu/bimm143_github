---
title: "lab12"
author: "Ariane"
format: pdf
editor_options: 
  chunk_output_type: inline
---

```{r, echo=FALSE}
library(BiocManager)
library(DESeq2)
```

## Importing countData and colData

```{r}
counts <- read.csv("airway_scaledcounts.csv", row.names=1)
metadata <-  read.csv("airway_metadata.csv")
```

```{r}
head(counts)
```

```{r}
head(metadata)
```

Q1. How many genes are in this dataset? 

There are `r nrow(counts)` genes in this dataset. 

Q2. How many ‘control’ cell lines do we have? 

```{r}
n.control <- sum(metadata$dex == "control")
```

There are `r n.control` control cell lines in this dataset. 

## Extract and summarize the control samples

To find out where the control samples are we need the metadata. 

```{r}
control <- metadata[metadata[,"dex"]=="control",]
control.counts <- counts[ ,control$id]
head(control.counts)
```

```{r}
control.mean <- rowMeans(control.counts)
head(control.mean)
```




```{r}
library(dplyr)
control <- metadata %>% filter(dex=="control")
control.counts <- counts %>% select(control$id) 
control.mean <- rowSums(control.counts)/4
head(control.mean)
```

Q3. How would you make the above code in either approach more robust?

We could make the above code in either approach more robust by not using `rowSums()` and manually dividing it by 4. Instead, we use `rowMeans()` which would give more robust results not matter the sample size. 

Q4. Follow the same procedure for the treated samples (i.e. calculate the mean per gene across drug treated samples and assign to a labeled vector called treated.mean)

```{r}
treated <- metadata[metadata[,"dex"]=="treated",]
treated.counts <- counts[ ,treated$id]
treated.mean <- rowMeans(treated.counts)
head(treated.mean)
```

Store these results together in a new data frame called `meancounts`.

```{r}
meancounts <- data.frame(control.mean, treated.mean)
```

Q5 (a). Create a scatter plot showing the mean of the treated samples against the mean of the control samples. Your plot should look something like the following.

```{r}
plot(meancounts[, 1], meancounts[,2])
```

Q5 (b).You could also use the ggplot2 package to make this figure producing the plot below. What geom_?() function would you use for this plot?

```{r}
library(ggplot2)
ggplot(meancounts, aes(control.mean, treated.mean)) + geom_point() 
```

Q6. Try plotting both axes on a log scale. What is the argument to plot() that allows you to do this? 

```{r}
plot(meancounts[, 1], meancounts[,2], log="xy", xlab="log control counts", ylab ="log of treated counts")
```


```{r}
ggplot(meancounts, aes(control.mean, treated.mean)) + geom_point() + scale_x_continuous(trans="log2") + scale_y_continuous(trans="log2")
```

This log2 transformation has the nice property where if there is no change the log2 value will be zero and if it doubles log2 value will be 1, and if havles it will be -1.

```{r}
meancounts$log2fc <- log2(meancounts[,"treated.mean"]/meancounts[,"control.mean"])
head(meancounts)
```


Q7. What is the purpose of the arr.ind argument in the which() function call above? Why would we then take the first column of the output and need to call the unique() function?

```{r}
head(which(meancounts[,1:2]==0, arr.ind = TRUE))
```
The arr.ind argument will give the names or index of the row where it exists a zero. 

```{r}
zero.vals <- which(meancounts[,1:2]==0, arr.ind=TRUE)

to.rm <- unique(zero.vals[,1])
mycounts <- meancounts[-to.rm,]
head(mycounts)
```

We need to call `unique()` function because there might be multiple zeroes in one row. 

A common threshold used for calling something differentially expressed is a log2(FoldChange) of greater than 2 or less than -2. Let’s filter the dataset both ways to see how many genes are up or down-regulated.

```{r}
up.ind <- mycounts$log2fc > 2
down.ind <- mycounts$log2fc < (-2)
```

Q8. Using the up.ind vector above can you determine how many up regulated genes we have at the greater than 2 fc level? 

```{r}
sum(up.ind)
```

Q9. Using the down.ind vector above can you determine how many down regulated genes we have at the greater than 2 fc level? 

```{r}
sum(down.ind)
```


Q10. Do you trust these results? Why or why not?

Not fully because we don't really know if these changes are statistically significant. 

## DESeq2 Analysis

```{r}
# load up DESeq2
library(DESeq2)
```

```{r}
dds <- DESeqDataSetFromMatrix(countData=counts, 
                              colData=metadata, 
                              design=~dex)
```

```{r}
dds <- DESeq(dds)
```

```{r}
res <- results(dds)
res
```

We can get some basic summary tallies using the `summary()` function.

```{r}
summary(res, alpha=0.05)
```
## Volcano plot

Make a summary plot of our results. 

```{r}
plot(res$log2FoldChange,res$padj)
```


```{r}
plot(res$log2FoldChange,-log(res$padj))
```


```{r}
# Setup our custom point color vector 
mycols <- rep("gray", nrow(res))
mycols[ abs(res$log2FoldChange) > 2 ]  <- "red" 

inds <- (res$padj < 0.01) & (abs(res$log2FoldChange) > 2 )
mycols[ inds ] <- "blue"

# Volcano plot with custom colors 
plot( res$log2FoldChange,  -log(res$padj), 
 col=mycols, ylab="-Log(P-value)", xlab="Log2(FoldChange)" )

# Cut-off lines
abline(v=c(-2,2), col="gray", lty=2)
abline(h=-log(0.1), col="gray", lty=2)
```

We will use one of Bioconductor’s main annotation packages to help with mapping between various ID schemes. Here we load the `AnnotationDbi` package and the annotation data package for humans `org.Hs.eg.db`.

```{r}
library("AnnotationDbi")
library("org.Hs.eg.db")
```

Look at what types of IDs I can translate between from the `org.Hs.eg.db` package with the `column()` function. 

```{r}
columns(org.Hs.eg.db)
```
```{r}
head(res)
```


```{r}
res$symbol <- mapIds(x=org.Hs.eg.db, 
                     column="SYMBOL",
                     keys=rownames(res),
                     keytype="ENSEMBL",
                     multiVals="first")
head(res)
```

```{r}
res$entrez <- mapIds(x=org.Hs.eg.db, 
                     column="ENTREZID",
                     keys=rownames(res),
                     keytype="ENSEMBL",
                     multiVals="first")
head(res)
```

## Pathway analysis 

```{r}
library(gage)
library(gageData)

data(kegg.sets.hs)
data(sigmet.idx.hs)

# Focus on signaling and metabolic pathways only
kegg.sets.hs = kegg.sets.hs[sigmet.idx.hs]

# Examine the first 3 pathways
head(kegg.sets.hs, 3)
```

The main `gage()` function requires a named vector of fold changes, where the names of the values are the Entrez gene IDs.

```{r}
foldchanges = res$log2FoldChange
names(foldchanges) = res$entrez
head(foldchanges)
```

```{r}
keggres = gage(foldchanges, gsets=kegg.sets.hs)
```

```{r}
attributes(keggres)
```

Now lets look at the object returned from `gage()`, i.e. our results here:

```{r}
head(keggres$less,3)
```


```{r}
library(pathview)
pathview(gene.data=foldchanges, pathway.id="hsa04110")
```

Put this into my document.

![This Asthma pathway with my highlighted differentially expressed genes in color](hsa04110.pathview.png)